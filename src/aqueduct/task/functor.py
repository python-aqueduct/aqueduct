import inspect

from typing import Any, Generic, Optional, TypeVar
from aqueduct.artifact.artifact import ArtifactSpec
from aqueduct.config import ConfigSpec
from aqueduct.task.abstract_task import AbstractTask
from aqueduct.task.task import Task
from aqueduct.task_tree import TaskTree
from .autoresolve import WrapInitMeta

_T = TypeVar("_T")
_U = TypeVar("_U")
_V = TypeVar("_V")


class MappedTask(Task, Generic[_T, _U]):
    """A MappedTask is the result of the application of a Functor on a Task. It is an
    usual task where some of the task components are auto-generated by the Functor
    application."""

    def __init__(self, task: AbstractTask[_T], functor: "Functor[_T, _U]"):
        self.task = task
        self.functor = functor

    def requirements(self) -> tuple[AbstractTask, TaskTree]:
        return self.task, self.functor.requirements()

    def run(self, requirements: tuple[_T, Any]) -> _U:
        task_output, functor_requirements = requirements
        return self.functor.mapping(task_output, functor_requirements)

    def artifact(self):
        return self.functor.artifact()

    def _unique_key(self) -> str:
        task_key = self.task._unique_key()
        functor_key = "-".join([self.functor_name(), self._args_hash])  # type: ignore

        return "--".join([functor_key, task_key])

    @classmethod
    def functor_name(cls) -> str:
        return cls.__qualname__


class Functor(Generic[_T, _U], metaclass=WrapInitMeta):
    """A Functor is a mapping on a Task. It turns a Task into another Task. This is
    useful to apply a configurable transformation to the output of a task."""

    CONFIG: ConfigSpec = None
    """The configuration of the Task class. It specifies how the `config` method should
    behave. If set to a dict-like object, that mapping is used as configuration. If set
    to a `str`, the string is used as a key to retrieve the configuration from the
    global configuration dict. If set to `None`, the full class name is used as the
    configuration section for the task."""

    def __init__(self):
        # These values are set by the wrapper around __init__ introduced by
        # `WrapInitMeta`.
        self._args = None
        self._kwargs = None

    def __call__(self, task: AbstractTask) -> MappedTask[_T, _U]:
        """Apply the functor to a task."""
        return MappedTask(task, self)

    def mapping(self, task_output: _T, requirements: Any) -> _U:
        raise NotImplementedError("Functor must implement mapping method.")

    def requirements(self) -> TaskTree:
        return None

    def artifact(self) -> Optional[ArtifactSpec]:
        return None

    @classmethod
    def _fully_qualified_name(cls) -> str:
        """Full module path to the task."""
        module = inspect.getmodule(cls)

        if module is None:
            raise RuntimeError("Could not recover module for Task.")

        return module.__name__ + "." + cls.__qualname__
