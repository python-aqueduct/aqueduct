"""Functors are transformations applied to tasks. They are used to modify the output of a task
before it is passed to the next task in the pipeline. Functors are useful to apply a configurable
transformation to the output of a task.
"""

import inspect

from typing import Any, Generic, Optional, TypeVar
from aqueduct.artifact.artifact import ArtifactSpec
from aqueduct.config import ConfigSpec
from aqueduct.task.abstract_task import AbstractTask
from aqueduct.task.task import Task
from aqueduct.task_tree import TaskTree
from .autoresolve import WrapInitMeta

_T = TypeVar("_T")
_U = TypeVar("_U")
_V = TypeVar("_V")


class MappedTask(Task, Generic[_T, _U]):
    """A MappedTask is the result of the application of a Functor on a Task. It is an
    usual task where some of the task components are auto-generated by the Functor
    application."""

    def __init__(self, task: AbstractTask[_T], functor: "Functor[_T, _U]"):
        self.task = task
        self.functor = functor

    def requirements(self) -> tuple[AbstractTask, TaskTree]:
        """The requirements of the MappedTask.

        Returns:
            A tuple with the task begin transformed and the requirements of the Functor.
        """
        return self.task, self.functor.requirements()

    def run(self, requirements: tuple[_T, Any]) -> _U:
        task_output, functor_requirements = requirements
        return self.functor.mapping(task_output, functor_requirements)

    def artifact(self):
        """The artifact of the MappedTask. This is generated by calling the :meth:`Functor.artifact`
        method of the Functor."""
        return self.functor.artifact(self.task)

    def _unique_key(self) -> str:
        task_key = self.task._unique_key()
        functor_key = "-".join([self.functor_name(), self._args_hash])  # type: ignore

        return "--".join([functor_key, task_key])


class Functor(Generic[_T, _U], metaclass=WrapInitMeta):
    """A Functor is a mapping on a Task. It turns a Task into another Task. This is
    useful to apply a configurable transformation to the output of a task."""

    CONFIG: ConfigSpec = None

    def __init__(self):
        # These values are set by the wrapper around __init__ introduced by
        # `WrapInitMeta`.
        self._args = None
        self._kwargs = None

    def __call__(self, task: AbstractTask) -> MappedTask[_T, _U]:
        """Apply the functor to a task.

        Args:
            task: The task begin transformed by the Functor.

        Returns:
            A MappedTask that is the result of the application of the Functor on the task.
        """
        return MappedTask(task, self)

    def mapping(self, task_output: _T, requirements: Any) -> _U:
        """The mapping function of the Functor. This is the transformation applied to
        output of the task. It also receives the Functor requirements as an argument.

        Args:
            task_output: The output of the task.
            requirements: The resolved requirements of the Functor.
        """
        raise NotImplementedError("Functor must implement mapping method.")

    def requirements(self) -> TaskTree:
        """The requirements of the Functor. These requirements are resolved and passed
        to the `mapping` function before it is called."""
        return None

    def artifact(self, mapped_task: AbstractTask[_T]) -> Optional[ArtifactSpec]:
        """The Functor artifact. You should ensure the artifact path depends on both the
        Functor and the mapped task, otherwise there could be artifact path collisions.

        Args:
            mapped_task: The task that will be modified by the functor.

        Returns:
            The artifact specification for the Functor x Task application.
            None if there is no artifact.
        """
        return None

    @classmethod
    def _fully_qualified_name(cls) -> str:
        """Full module path to the task."""
        module = inspect.getmodule(cls)

        if module is None:
            raise RuntimeError("Could not recover module for Task.")

        return module.__name__ + "." + cls.__qualname__

    @classmethod
    def ui_name(cls) -> str:
        return cls.__qualname__
